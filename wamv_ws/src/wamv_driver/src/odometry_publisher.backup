#! /usr/bin/env python

import rospy
# import tf
import math
import message_filters
from geometry_msgs.msg import Twist, Quaternion
from sensor_msgs.msg import Imu
from nav_msgs.msg import Odometry

###############################################################################
class OdometryPublisher():

    ###########################################################################
    def __init__(self):
        # Initialize node
        rospy.init_node('imu_odometry_estimation', log_level=rospy.INFO)

        # Get parameters
        self.rot_cov = rospy.get_param("~rot_covariance", 99999.0)

        # Set up subscribers
        message_filters.ApproximateTimeSynchronizer((
            message_filters.Subscriber('twist', Twist),
            message_filters.Subscriber('imu', Imu)),
            10, 0.1, allow_headerless=True
        ).registerCallback(self.callback)

        # Set up publisher
        self.odom_publisher = rospy.Publisher(
            'odom', Odometry, queue_size=10
        )

        # Initialize class variables
        self.odom = Odometry()
        self.odom.header.frame_id = rospy.get_param("~frame_id", "odom")
        self.odom.child_frame_id = rospy.get_param("~child_frame_id", "an_device")
        # self.odom.pose.pose.position.x = 0.0
        # self.odom.pose.pose.position.y = 0.0
        # self.odom.pose.pose.position.z = 0.0

        self.previous_time = None

    ###########################################################################
    def callback(self, twist_msg, imu_msg):
        """ TODO

            Twist in this message corresponds to the robot's velocity in the
            child frame, normally the coordinate frame of the mobile base,
            along with an optional covariance for the certainty of that
            velocity estimate.

            Pose in this message corresponds to the estimated position of the
            robot in the odometric frame along with an optional covariance for
            the certainty of that pose estimate.
        """
        self.odom.header.stamp = imu_msg.header.stamp
        if self.previous_time is None:
            self.previous_time = self.odom.header.stamp
            return

        # quaternion = (
        #     imu_msg.orientation.x, imu_msg.orientation.y,
        #     imu_msg.orientation.z, imu_msg.orientation.w
        # )

        self.odom.pose.pose.orientation = imu_msg.orientation

        ori = tf.transformations.euler_from_quaternion(imu_msg.orientation)
        quat = tf.transformations.quaternion_from_euler(0, 0, ori[2])
        # self.odom.pose.pose.orientation.x = quat[0]
        # self.odom.pose.pose.orientation.y = quat[1]
        # self.odom.pose.pose.orientation.z = quat[2]
        # self.odom.pose.pose.orientation.w = quat[3]

        theta = ori[2]

        self.odom.twist.twist.linear.x = twist_msg.linear.x
        self.odom.twist.twist.linear.y = twist_msg.linear.y
        # self.odom.twist.twist.linear.z = twist_msg.linear.z
        # self.odom.twist.twist.angular.x = twist_msg.angular.x
        # self.odom.twist.twist.angular.y = twist_msg.angular.y
        # self.odom.twist.twist.angular.z = twist_msg.angular.z


        dt = (self.odom.header.stamp - self.previous_time).to_sec()
        self.odom.pose.pose.position.x += dt * (
            self.odom.twist.twist.linear.x * math.cos(theta)
          - self.odom.twist.twist.linear.y * math.sin(theta)
        )
        self.odom.pose.pose.position.y += dt * (
            self.odom.twist.twist.linear.x * math.sin(theta)
          + self.odom.twist.twist.linear.y * math.cos(theta)
        )
        # self.odom.pose.pose.position.z += dt * self.odom.twist.twist.linear.z

        self.odom_publisher.publish(self.odom)

        self.previous_time = self.odom.header.stamp

    ###########################################################################
    # def nav_sat_fix_callback(self, msg):
    #     if (msg.status.status == -1):
    #         rospy.loginfo("NO FIX.")
    #         return
    #
    #     if (msg.header.stamp == rospy.Time(0)):
    #         return
    #
    #     self.odom.header.stamp = msg.header.stamp
    #
    #     (northing, easting) = LLtoUTM(msg.latitude, msg.longitude)
    #     self.odom.pose.pose.position.x = easting #- ox
    #     self.odom.pose.pose.position.y = northing #- oy
    #     self.odom.pose.pose.position.z = 0.0
    #
    #     covariance = [
    #         msg.position_covariance[0],
    #         msg.position_covariance[1],
    #         msg.position_covariance[2],
    #         0, 0, 0,
    #         msg.position_covariance[3],
    #         msg.position_covariance[4],
    #         msg.position_covariance[5],
    #         0, 0, 0,
    #         msg.position_covariance[6],
    #         msg.position_covariance[7],
    #         msg.position_covariance[8],
    #         0, 0, 0,
    #         0, 0, 0,
    #         self.rot_cov, 0, 0,
    #         0, 0, 0,
    #         0, self.rot_cov, 0,
    #         0, 0, 0,
    #         0, 0, self.rot_cov
    #     ]
    #     self.odom.pose.covariance = covariance
    #
    #     # Publish odometry topic
    #     self.odom_pub.publish(self.odom)


###############################################################################
###############################################################################
if __name__ == '__main__':
    try:
        odometry = OdometryPublisher()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
